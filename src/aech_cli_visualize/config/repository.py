"""Config repository for storing and retrieving dashboard specifications."""

import json
from datetime import datetime
from pathlib import Path
from typing import Any

from .fingerprint import compute_schema_fingerprint
from .models import ConfigIndex, ConfigMetadata


class ConfigRepository:
    """Manages dashboard configurations in ~/.aech/visualize/configs/."""

    DEFAULT_PATH = Path.home() / ".aech" / "visualize" / "configs"

    def __init__(self, base_path: Path | None = None):
        """Initialize the repository.

        Args:
            base_path: Base path for the repository. Defaults to ~/.aech/visualize/configs/
        """
        self.base_path = base_path or self.DEFAULT_PATH
        self.specs_dir = self.base_path / "specs"
        self.previews_dir = self.base_path / "previews"
        self.index_path = self.base_path / "index.json"

        # Ensure directories exist
        self._ensure_dirs()

    def _ensure_dirs(self) -> None:
        """Create repository directories if they don't exist."""
        self.base_path.mkdir(parents=True, exist_ok=True)
        self.specs_dir.mkdir(exist_ok=True)
        self.previews_dir.mkdir(exist_ok=True)

        if not self.index_path.exists():
            self._write_index(ConfigIndex())

    def _read_index(self) -> ConfigIndex:
        """Read the config index."""
        with open(self.index_path) as f:
            data = json.load(f)
            return ConfigIndex.model_validate(data)

    def _write_index(self, index: ConfigIndex) -> None:
        """Write the config index."""
        with open(self.index_path, "w") as f:
            json.dump(
                index.model_dump(mode="json"),
                f,
                indent=2,
                default=str,
            )

    def save(
        self,
        spec: dict[str, Any],
        name: str,
        tags: list[str] | None = None,
        description: str | None = None,
        data_for_fingerprint: dict[str, Any] | None = None,
    ) -> ConfigMetadata:
        """Save a dashboard spec to the repository.

        Args:
            spec: Dashboard specification dictionary
            name: Human-readable name for the config
            tags: Optional tags for categorization
            description: Optional description
            data_for_fingerprint: Original data to compute schema fingerprint

        Returns:
            ConfigMetadata for the saved config
        """
        # Check for duplicate names
        index = self._read_index()
        for existing in index.configs:
            if existing.name == name:
                raise ValueError(f"Config with name '{name}' already exists")

        # Compute fingerprint
        fingerprint = ""
        if data_for_fingerprint:
            fingerprint = compute_schema_fingerprint(data_for_fingerprint)

        # Create metadata (id is auto-generated by default_factory)
        metadata = ConfigMetadata(
            name=name,
            description=description,
            tags=tags or [],
            schema_fingerprint=fingerprint,
            spec_path="",  # Will be set below
        )
        metadata.spec_path = f"specs/{metadata.id}.json"

        # Write spec file
        spec_file = self.base_path / metadata.spec_path
        with open(spec_file, "w") as f:
            json.dump(spec, f, indent=2)

        # Update index
        index.configs.append(metadata)
        self._write_index(index)

        return metadata

    def get_by_name(self, name: str) -> tuple[ConfigMetadata, dict[str, Any]] | None:
        """Get config by name.

        Args:
            name: Config name to retrieve

        Returns:
            Tuple of (metadata, spec) or None if not found
        """
        index = self._read_index()
        for config in index.configs:
            if config.name == name:
                return self._load_config(config)
        return None

    def get_by_id(self, config_id: str) -> tuple[ConfigMetadata, dict[str, Any]] | None:
        """Get config by ID.

        Args:
            config_id: Config UUID to retrieve

        Returns:
            Tuple of (metadata, spec) or None if not found
        """
        index = self._read_index()
        for config in index.configs:
            if config.id == config_id:
                return self._load_config(config)
        return None

    def get(self, name_or_id: str) -> tuple[ConfigMetadata, dict[str, Any]] | None:
        """Get config by name or ID.

        Args:
            name_or_id: Config name or UUID

        Returns:
            Tuple of (metadata, spec) or None if not found
        """
        # Try by name first (more common)
        result = self.get_by_name(name_or_id)
        if result:
            return result
        # Try by ID
        return self.get_by_id(name_or_id)

    def _load_config(
        self, metadata: ConfigMetadata
    ) -> tuple[ConfigMetadata, dict[str, Any]]:
        """Load config spec and update usage stats."""
        spec_file = self.base_path / metadata.spec_path
        with open(spec_file) as f:
            spec = json.load(f)

        # Update usage stats
        index = self._read_index()
        for config in index.configs:
            if config.id == metadata.id:
                config.last_used_at = datetime.utcnow()
                config.usage_count += 1
                break
        self._write_index(index)

        return metadata, spec

    def find_by_fingerprint(
        self, fingerprint: str, limit: int = 5
    ) -> list[ConfigMetadata]:
        """Find configs matching a schema fingerprint.

        Args:
            fingerprint: Schema fingerprint to match
            limit: Maximum number of results

        Returns:
            List of matching ConfigMetadata
        """
        index = self._read_index()
        matches = [c for c in index.configs if c.schema_fingerprint == fingerprint]
        return matches[:limit]

    def find_by_data(
        self, data: dict[str, Any], limit: int = 5
    ) -> list[ConfigMetadata]:
        """Find configs matching data schema.

        Args:
            data: Data dictionary to compute fingerprint from
            limit: Maximum number of results

        Returns:
            List of matching ConfigMetadata
        """
        fingerprint = compute_schema_fingerprint(data)
        return self.find_by_fingerprint(fingerprint, limit)

    def list_configs(
        self, tags: list[str] | None = None, limit: int = 20
    ) -> list[ConfigMetadata]:
        """List configs, optionally filtered by tags.

        Args:
            tags: Optional tags to filter by (any match)
            limit: Maximum number of results

        Returns:
            List of ConfigMetadata sorted by most recently used
        """
        index = self._read_index()
        configs = index.configs

        if tags:
            configs = [c for c in configs if any(t in c.tags for t in tags)]

        # Sort by last_used_at (most recent first), then created_at
        configs.sort(
            key=lambda c: c.last_used_at or c.created_at,
            reverse=True,
        )

        return configs[:limit]

    def delete(self, name_or_id: str) -> bool:
        """Delete a config from the repository.

        Args:
            name_or_id: Config name or UUID to delete

        Returns:
            True if deleted, False if not found
        """
        index = self._read_index()
        to_delete = None

        for config in index.configs:
            if config.name == name_or_id or config.id == name_or_id:
                to_delete = config
                break

        if not to_delete:
            return False

        # Delete spec file
        spec_file = self.base_path / to_delete.spec_path
        if spec_file.exists():
            spec_file.unlink()

        # Delete preview if exists
        if to_delete.preview_path:
            preview_file = self.base_path / to_delete.preview_path
            if preview_file.exists():
                preview_file.unlink()

        # Update index
        index.configs = [c for c in index.configs if c.id != to_delete.id]
        self._write_index(index)

        return True

    def update_preview(self, name_or_id: str, preview_path: Path) -> bool:
        """Update the preview image for a config.

        Args:
            name_or_id: Config name or UUID
            preview_path: Path to the preview image to copy

        Returns:
            True if updated, False if config not found
        """
        index = self._read_index()

        for config in index.configs:
            if config.name == name_or_id or config.id == name_or_id:
                # Copy preview to repository
                dest = self.previews_dir / f"{config.id}.png"
                import shutil

                shutil.copy(preview_path, dest)

                # Update metadata
                config.preview_path = f"previews/{config.id}.png"
                self._write_index(index)
                return True

        return False
